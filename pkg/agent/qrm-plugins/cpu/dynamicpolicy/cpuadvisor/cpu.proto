/*
Copyright 2022 The Katalyst Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

syntax = 'proto3';

package cpuadvisor;

import "github.com/gogo/protobuf/gogoproto/gogo.proto";
import "github.com/kubewharf/kubelet/pkg/apis/resourceplugin/v1alpha1/api.proto";
import "github.com/kubewharf/katalyst-core/pkg/agent/qrm-plugins/advisorsvc/advisor_svc.proto";

option (gogoproto.goproto_stringer_all) = false;
option (gogoproto.stringer_all) =  true;
option (gogoproto.goproto_getters_all) = true;
option (gogoproto.marshaler_all) = true;
option (gogoproto.sizer_all) = true;
option (gogoproto.unmarshaler_all) = true;
option (gogoproto.goproto_unrecognized_all) = false;

option go_package = "github.com/kubewharf/katalyst-core/pkg/agent/qrm-plugins/cpu/dynamicpolicy/cpuadvisor";

message ListAndWatchResponse {
    map<string,CalculationEntries> entries = 1; // keyed by pool name or podUID
}

message CalculationEntries {
    map<string,CalculationInfo> entries = 1; // keyed by "" (for pool) or container name (for container)
}

message CalculationInfo {
    // valid values:
    // 1. "dedicated" (dedicated_cores container with or without numa_biding)
    // 2. real pool name (shared_cores container entries and pool entries)ï¼Œ, including:
    //    - common pools (eg. share, reclaim, flink, batch, bmq)
    //    - pools generated by qos aware server containing isolated shared_cores containers (eg. isolation0, isolation1, ...)
    string owner_pool_name = 1;
    map<int64, NumaCalculationResult> calculation_results_by_numas = 2; // keyed by NUMA id
}

message NumaCalculationResult {
    // every block doesn't overlap with other blocks in same NumaCalculationResult
    repeated Block blocks = 2;
}

message Block {
    uint64 result = 1;
    repeated OverlapTarget overlap_targets = 2;
    string block_id = 3;
}

message OverlapTarget {
    string overlap_target_pool_name = 1;
    string overlap_target_pod_uid = 2;
    string overlap_target_container_name = 3;
    OverlapType overlap_type = 4;
}

enum OverlapType {
    OverlapWithPod = 0;
    OverlapWithPool = 1;
}

message GetCheckpointRequest {
}

message GetCheckpointResponse {
    map<string,AllocationEntries> entries = 1; // keyed by pool name or podUID
}

message AllocationEntries {
    map<string,AllocationInfo> entries = 1; // keyed by "" (for pool) or container name (for container)
}

message AllocationInfo {
    bool ramp_up = 1;
    // owner_pool_name indicates the real pool this entry belongs to, it may equal to 
    // 1. real pool name shows up explicitly in GetCheckpointResponse, including:
    //    - common pools (eg. share, reclaim, flink, batch, bmq)
    //    - pools generated by qos aware server containing isolated shared_cores containers (eg. isolation0, isolation1, ...)
    // 2. "dedicated" (dedicated_cores container with or without numa_biding)
    // 3. "fallback" (dedicated_cores without numa_binding will be put to this fake pool when it can't allocate isolated cpuset for them), there is no AllocationInfo for this fake pool 
    // 4. empty (the entry is ramping up)
    string owner_pool_name = 2;  
    map<uint64,string> topology_aware_assignments = 3; // keyed by NUMA id
    map<uint64,string> original_topology_aware_assignments = 4; // keyed by NUMA id
}

service CPUAdvisor {
    rpc AddContainer(advisorsvc.ContainerMetadata) returns (advisorsvc.AddContainerResponse) {}
    rpc RemovePod(advisorsvc.RemovePodRequest) returns (advisorsvc.RemovePodResponse) {}
    rpc ListAndWatch(advisorsvc.Empty) returns (stream ListAndWatchResponse) {}
}

service CPUPlugin {
    rpc GetCheckpoint(GetCheckpointRequest) returns (GetCheckpointResponse) {}
}
