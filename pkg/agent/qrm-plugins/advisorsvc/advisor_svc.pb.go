/*
Copyright 2022 The Katalyst Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ // Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: advisor_svc.proto

package advisorsvc

import (
	context "context"
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"

	v1alpha1 "k8s.io/kubelet/pkg/apis/resourceplugin/v1alpha1"
)

// Reference imports to suppress errors if they are not otherwise used.
var (
	_ = proto.Marshal
	_ = fmt.Errorf
	_ = math.Inf
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// containing metadata of the container which won't be changed during container's lifecycle
type ContainerMetadata struct {
	PodUid               string                 `protobuf:"bytes,1,opt,name=pod_uid,json=podUid,proto3" json:"pod_uid,omitempty"`
	PodNamespace         string                 `protobuf:"bytes,2,opt,name=pod_namespace,json=podNamespace,proto3" json:"pod_namespace,omitempty"`
	PodName              string                 `protobuf:"bytes,3,opt,name=pod_name,json=podName,proto3" json:"pod_name,omitempty"`
	ContainerName        string                 `protobuf:"bytes,4,opt,name=container_name,json=containerName,proto3" json:"container_name,omitempty"`
	ContainerType        v1alpha1.ContainerType `protobuf:"varint,5,opt,name=container_type,json=containerType,proto3,enum=resourceplugin.v1alpha1.ContainerType" json:"container_type,omitempty"`
	ContainerIndex       uint64                 `protobuf:"varint,6,opt,name=container_index,json=containerIndex,proto3" json:"container_index,omitempty"`
	Labels               map[string]string      `protobuf:"bytes,7,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Annotations          map[string]string      `protobuf:"bytes,8,rep,name=annotations,proto3" json:"annotations,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	QosLevel             string                 `protobuf:"bytes,9,opt,name=qos_level,json=qosLevel,proto3" json:"qos_level,omitempty"`
	RequestQuantity      uint64                 `protobuf:"varint,10,opt,name=requestQuantity,proto3" json:"requestQuantity,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *ContainerMetadata) Reset()      { *m = ContainerMetadata{} }
func (*ContainerMetadata) ProtoMessage() {}
func (*ContainerMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_870376c87c2a4145, []int{0}
}

func (m *ContainerMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}

func (m *ContainerMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContainerMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}

func (m *ContainerMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContainerMetadata.Merge(m, src)
}

func (m *ContainerMetadata) XXX_Size() int {
	return m.Size()
}

func (m *ContainerMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_ContainerMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_ContainerMetadata proto.InternalMessageInfo

func (m *ContainerMetadata) GetPodUid() string {
	if m != nil {
		return m.PodUid
	}
	return ""
}

func (m *ContainerMetadata) GetPodNamespace() string {
	if m != nil {
		return m.PodNamespace
	}
	return ""
}

func (m *ContainerMetadata) GetPodName() string {
	if m != nil {
		return m.PodName
	}
	return ""
}

func (m *ContainerMetadata) GetContainerName() string {
	if m != nil {
		return m.ContainerName
	}
	return ""
}

func (m *ContainerMetadata) GetContainerType() v1alpha1.ContainerType {
	if m != nil {
		return m.ContainerType
	}
	return v1alpha1.ContainerType_INIT
}

func (m *ContainerMetadata) GetContainerIndex() uint64 {
	if m != nil {
		return m.ContainerIndex
	}
	return 0
}

func (m *ContainerMetadata) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *ContainerMetadata) GetAnnotations() map[string]string {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *ContainerMetadata) GetQosLevel() string {
	if m != nil {
		return m.QosLevel
	}
	return ""
}

func (m *ContainerMetadata) GetRequestQuantity() uint64 {
	if m != nil {
		return m.RequestQuantity
	}
	return 0
}

type AddContainerResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AddContainerResponse) Reset()      { *m = AddContainerResponse{} }
func (*AddContainerResponse) ProtoMessage() {}
func (*AddContainerResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_870376c87c2a4145, []int{1}
}

func (m *AddContainerResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}

func (m *AddContainerResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddContainerResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}

func (m *AddContainerResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddContainerResponse.Merge(m, src)
}

func (m *AddContainerResponse) XXX_Size() int {
	return m.Size()
}

func (m *AddContainerResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AddContainerResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AddContainerResponse proto.InternalMessageInfo

type Empty struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Empty) Reset()      { *m = Empty{} }
func (*Empty) ProtoMessage() {}
func (*Empty) Descriptor() ([]byte, []int) {
	return fileDescriptor_870376c87c2a4145, []int{2}
}

func (m *Empty) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}

func (m *Empty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Empty.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}

func (m *Empty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Empty.Merge(m, src)
}

func (m *Empty) XXX_Size() int {
	return m.Size()
}

func (m *Empty) XXX_DiscardUnknown() {
	xxx_messageInfo_Empty.DiscardUnknown(m)
}

var xxx_messageInfo_Empty proto.InternalMessageInfo

type RemovePodRequest struct {
	PodUid               string   `protobuf:"bytes,1,opt,name=pod_uid,json=podUid,proto3" json:"pod_uid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RemovePodRequest) Reset()      { *m = RemovePodRequest{} }
func (*RemovePodRequest) ProtoMessage() {}
func (*RemovePodRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_870376c87c2a4145, []int{3}
}

func (m *RemovePodRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}

func (m *RemovePodRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemovePodRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}

func (m *RemovePodRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemovePodRequest.Merge(m, src)
}

func (m *RemovePodRequest) XXX_Size() int {
	return m.Size()
}

func (m *RemovePodRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RemovePodRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RemovePodRequest proto.InternalMessageInfo

func (m *RemovePodRequest) GetPodUid() string {
	if m != nil {
		return m.PodUid
	}
	return ""
}

type RemovePodResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RemovePodResponse) Reset()      { *m = RemovePodResponse{} }
func (*RemovePodResponse) ProtoMessage() {}
func (*RemovePodResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_870376c87c2a4145, []int{4}
}

func (m *RemovePodResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}

func (m *RemovePodResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemovePodResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}

func (m *RemovePodResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemovePodResponse.Merge(m, src)
}

func (m *RemovePodResponse) XXX_Size() int {
	return m.Size()
}

func (m *RemovePodResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RemovePodResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RemovePodResponse proto.InternalMessageInfo

type ListAndWatchResponse struct {
	PodEntries           map[string]*CalculationEntries `protobuf:"bytes,1,rep,name=pod_entries,json=podEntries,proto3" json:"pod_entries,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	ExtraEntries         []*CalculationInfo             `protobuf:"bytes,2,rep,name=extra_entries,json=extraEntries,proto3" json:"extra_entries,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                       `json:"-"`
	XXX_sizecache        int32                          `json:"-"`
}

func (m *ListAndWatchResponse) Reset()      { *m = ListAndWatchResponse{} }
func (*ListAndWatchResponse) ProtoMessage() {}
func (*ListAndWatchResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_870376c87c2a4145, []int{5}
}

func (m *ListAndWatchResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}

func (m *ListAndWatchResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListAndWatchResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}

func (m *ListAndWatchResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListAndWatchResponse.Merge(m, src)
}

func (m *ListAndWatchResponse) XXX_Size() int {
	return m.Size()
}

func (m *ListAndWatchResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListAndWatchResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListAndWatchResponse proto.InternalMessageInfo

func (m *ListAndWatchResponse) GetPodEntries() map[string]*CalculationEntries {
	if m != nil {
		return m.PodEntries
	}
	return nil
}

func (m *ListAndWatchResponse) GetExtraEntries() []*CalculationInfo {
	if m != nil {
		return m.ExtraEntries
	}
	return nil
}

type CalculationEntries struct {
	ContainerEntries     map[string]*CalculationInfo `protobuf:"bytes,1,rep,name=container_entries,json=containerEntries,proto3" json:"container_entries,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *CalculationEntries) Reset()      { *m = CalculationEntries{} }
func (*CalculationEntries) ProtoMessage() {}
func (*CalculationEntries) Descriptor() ([]byte, []int) {
	return fileDescriptor_870376c87c2a4145, []int{6}
}

func (m *CalculationEntries) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}

func (m *CalculationEntries) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CalculationEntries.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}

func (m *CalculationEntries) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CalculationEntries.Merge(m, src)
}

func (m *CalculationEntries) XXX_Size() int {
	return m.Size()
}

func (m *CalculationEntries) XXX_DiscardUnknown() {
	xxx_messageInfo_CalculationEntries.DiscardUnknown(m)
}

var xxx_messageInfo_CalculationEntries proto.InternalMessageInfo

func (m *CalculationEntries) GetContainerEntries() map[string]*CalculationInfo {
	if m != nil {
		return m.ContainerEntries
	}
	return nil
}

type CalculationInfo struct {
	// eg. "/kubepods/besteffort";
	// empty for container; non-empty for high level cgroup path; since subsystem may be different for different control knob, so we use relative path here.
	CgroupPath           string             `protobuf:"bytes,1,opt,name=cgroup_path,json=cgroupPath,proto3" json:"cgroup_path,omitempty"`
	CalculationResult    *CalculationResult `protobuf:"bytes,2,opt,name=calculation_result,json=calculationResult,proto3" json:"calculation_result,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *CalculationInfo) Reset()      { *m = CalculationInfo{} }
func (*CalculationInfo) ProtoMessage() {}
func (*CalculationInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_870376c87c2a4145, []int{7}
}

func (m *CalculationInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}

func (m *CalculationInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CalculationInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}

func (m *CalculationInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CalculationInfo.Merge(m, src)
}

func (m *CalculationInfo) XXX_Size() int {
	return m.Size()
}

func (m *CalculationInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CalculationInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CalculationInfo proto.InternalMessageInfo

func (m *CalculationInfo) GetCgroupPath() string {
	if m != nil {
		return m.CgroupPath
	}
	return ""
}

func (m *CalculationInfo) GetCalculationResult() *CalculationResult {
	if m != nil {
		return m.CalculationResult
	}
	return nil
}

type CalculationResult struct {
	Values               map[string]string `protobuf:"bytes,1,rep,name=values,proto3" json:"values,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *CalculationResult) Reset()      { *m = CalculationResult{} }
func (*CalculationResult) ProtoMessage() {}
func (*CalculationResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_870376c87c2a4145, []int{8}
}

func (m *CalculationResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}

func (m *CalculationResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CalculationResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}

func (m *CalculationResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CalculationResult.Merge(m, src)
}

func (m *CalculationResult) XXX_Size() int {
	return m.Size()
}

func (m *CalculationResult) XXX_DiscardUnknown() {
	xxx_messageInfo_CalculationResult.DiscardUnknown(m)
}

var xxx_messageInfo_CalculationResult proto.InternalMessageInfo

func (m *CalculationResult) GetValues() map[string]string {
	if m != nil {
		return m.Values
	}
	return nil
}

type ContainerMetadataEntries struct {
	Entries              map[string]*ContainerMetadata `protobuf:"bytes,1,rep,name=entries,proto3" json:"entries,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                      `json:"-"`
	XXX_sizecache        int32                         `json:"-"`
}

func (m *ContainerMetadataEntries) Reset()      { *m = ContainerMetadataEntries{} }
func (*ContainerMetadataEntries) ProtoMessage() {}
func (*ContainerMetadataEntries) Descriptor() ([]byte, []int) {
	return fileDescriptor_870376c87c2a4145, []int{9}
}

func (m *ContainerMetadataEntries) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}

func (m *ContainerMetadataEntries) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContainerMetadataEntries.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}

func (m *ContainerMetadataEntries) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContainerMetadataEntries.Merge(m, src)
}

func (m *ContainerMetadataEntries) XXX_Size() int {
	return m.Size()
}

func (m *ContainerMetadataEntries) XXX_DiscardUnknown() {
	xxx_messageInfo_ContainerMetadataEntries.DiscardUnknown(m)
}

var xxx_messageInfo_ContainerMetadataEntries proto.InternalMessageInfo

func (m *ContainerMetadataEntries) GetEntries() map[string]*ContainerMetadata {
	if m != nil {
		return m.Entries
	}
	return nil
}

type GetAdviceRequest struct {
	Entries              map[string]*ContainerMetadataEntries `protobuf:"bytes,1,rep,name=entries,proto3" json:"entries,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                             `json:"-"`
	XXX_sizecache        int32                                `json:"-"`
}

func (m *GetAdviceRequest) Reset()      { *m = GetAdviceRequest{} }
func (*GetAdviceRequest) ProtoMessage() {}
func (*GetAdviceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_870376c87c2a4145, []int{10}
}

func (m *GetAdviceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}

func (m *GetAdviceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetAdviceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}

func (m *GetAdviceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAdviceRequest.Merge(m, src)
}

func (m *GetAdviceRequest) XXX_Size() int {
	return m.Size()
}

func (m *GetAdviceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAdviceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetAdviceRequest proto.InternalMessageInfo

func (m *GetAdviceRequest) GetEntries() map[string]*ContainerMetadataEntries {
	if m != nil {
		return m.Entries
	}
	return nil
}

type GetAdviceResponse struct {
	PodEntries           map[string]*CalculationEntries `protobuf:"bytes,1,rep,name=pod_entries,json=podEntries,proto3" json:"pod_entries,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	ExtraEntries         []*CalculationInfo             `protobuf:"bytes,2,rep,name=extra_entries,json=extraEntries,proto3" json:"extra_entries,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                       `json:"-"`
	XXX_sizecache        int32                          `json:"-"`
}

func (m *GetAdviceResponse) Reset()      { *m = GetAdviceResponse{} }
func (*GetAdviceResponse) ProtoMessage() {}
func (*GetAdviceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_870376c87c2a4145, []int{11}
}

func (m *GetAdviceResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}

func (m *GetAdviceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetAdviceResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}

func (m *GetAdviceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAdviceResponse.Merge(m, src)
}

func (m *GetAdviceResponse) XXX_Size() int {
	return m.Size()
}

func (m *GetAdviceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAdviceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetAdviceResponse proto.InternalMessageInfo

func (m *GetAdviceResponse) GetPodEntries() map[string]*CalculationEntries {
	if m != nil {
		return m.PodEntries
	}
	return nil
}

func (m *GetAdviceResponse) GetExtraEntries() []*CalculationInfo {
	if m != nil {
		return m.ExtraEntries
	}
	return nil
}

type ListContainersResponse struct {
	Containers           []*ContainerMetadata `protobuf:"bytes,1,rep,name=containers,proto3" json:"containers,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *ListContainersResponse) Reset()      { *m = ListContainersResponse{} }
func (*ListContainersResponse) ProtoMessage() {}
func (*ListContainersResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_870376c87c2a4145, []int{12}
}

func (m *ListContainersResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}

func (m *ListContainersResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListContainersResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}

func (m *ListContainersResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListContainersResponse.Merge(m, src)
}

func (m *ListContainersResponse) XXX_Size() int {
	return m.Size()
}

func (m *ListContainersResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListContainersResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListContainersResponse proto.InternalMessageInfo

func (m *ListContainersResponse) GetContainers() []*ContainerMetadata {
	if m != nil {
		return m.Containers
	}
	return nil
}

func init() {
	proto.RegisterType((*ContainerMetadata)(nil), "advisorsvc.ContainerMetadata")
	proto.RegisterMapType((map[string]string)(nil), "advisorsvc.ContainerMetadata.AnnotationsEntry")
	proto.RegisterMapType((map[string]string)(nil), "advisorsvc.ContainerMetadata.LabelsEntry")
	proto.RegisterType((*AddContainerResponse)(nil), "advisorsvc.AddContainerResponse")
	proto.RegisterType((*Empty)(nil), "advisorsvc.Empty")
	proto.RegisterType((*RemovePodRequest)(nil), "advisorsvc.RemovePodRequest")
	proto.RegisterType((*RemovePodResponse)(nil), "advisorsvc.RemovePodResponse")
	proto.RegisterType((*ListAndWatchResponse)(nil), "advisorsvc.ListAndWatchResponse")
	proto.RegisterMapType((map[string]*CalculationEntries)(nil), "advisorsvc.ListAndWatchResponse.PodEntriesEntry")
	proto.RegisterType((*CalculationEntries)(nil), "advisorsvc.CalculationEntries")
	proto.RegisterMapType((map[string]*CalculationInfo)(nil), "advisorsvc.CalculationEntries.ContainerEntriesEntry")
	proto.RegisterType((*CalculationInfo)(nil), "advisorsvc.CalculationInfo")
	proto.RegisterType((*CalculationResult)(nil), "advisorsvc.CalculationResult")
	proto.RegisterMapType((map[string]string)(nil), "advisorsvc.CalculationResult.ValuesEntry")
	proto.RegisterType((*ContainerMetadataEntries)(nil), "advisorsvc.ContainerMetadataEntries")
	proto.RegisterMapType((map[string]*ContainerMetadata)(nil), "advisorsvc.ContainerMetadataEntries.EntriesEntry")
	proto.RegisterType((*GetAdviceRequest)(nil), "advisorsvc.GetAdviceRequest")
	proto.RegisterMapType((map[string]*ContainerMetadataEntries)(nil), "advisorsvc.GetAdviceRequest.EntriesEntry")
	proto.RegisterType((*GetAdviceResponse)(nil), "advisorsvc.GetAdviceResponse")
	proto.RegisterMapType((map[string]*CalculationEntries)(nil), "advisorsvc.GetAdviceResponse.PodEntriesEntry")
	proto.RegisterType((*ListContainersResponse)(nil), "advisorsvc.ListContainersResponse")
}

func init() { proto.RegisterFile("advisor_svc.proto", fileDescriptor_870376c87c2a4145) }

var fileDescriptor_870376c87c2a4145 = []byte{
	// 984 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x56, 0xcb, 0x6f, 0xe3, 0x44,
	0x18, 0x8f, 0xd3, 0xf7, 0x97, 0x3e, 0x92, 0xa1, 0x2c, 0x26, 0x4b, 0x43, 0x64, 0x5e, 0x59, 0xa1,
	0x3a, 0xdb, 0xec, 0x1e, 0x60, 0x25, 0x10, 0xa1, 0xaa, 0xaa, 0x42, 0xbb, 0x6a, 0xcd, 0xa3, 0x02,
	0x09, 0x65, 0x27, 0xf6, 0x34, 0xb1, 0xea, 0x78, 0x5c, 0xcf, 0x38, 0x6c, 0x6e, 0x7b, 0xe0, 0xc4,
	0x09, 0xfe, 0x1c, 0xae, 0x88, 0xc3, 0x1e, 0x39, 0xc2, 0x8d, 0x0d, 0xff, 0x08, 0xf2, 0xf8, 0x91,
	0xb1, 0xf3, 0x28, 0x7b, 0xdd, 0x9b, 0xe7, 0x7b, 0xfc, 0xe6, 0xf7, 0xfd, 0xbe, 0xf1, 0x37, 0x03,
	0x15, 0x6c, 0x0d, 0x6d, 0x46, 0xfd, 0x0e, 0x1b, 0x9a, 0xba, 0xe7, 0x53, 0x4e, 0x11, 0xc4, 0x26,
	0x36, 0x34, 0xab, 0xfb, 0x3d, 0x9b, 0xf7, 0x83, 0xae, 0x6e, 0xd2, 0x41, 0xb3, 0x47, 0x7b, 0xb4,
	0x29, 0x42, 0xba, 0xc1, 0x95, 0x58, 0x89, 0x85, 0xf8, 0x8a, 0x52, 0xab, 0xc7, 0x52, 0xf8, 0x75,
	0xd0, 0x25, 0x3f, 0xf6, 0xb1, 0x7f, 0x25, 0xbe, 0x1c, 0xc2, 0x9b, 0xde, 0x75, 0xaf, 0x89, 0x3d,
	0x9b, 0x35, 0x7d, 0xc2, 0x68, 0xe0, 0x9b, 0xc4, 0x73, 0x82, 0x9e, 0xed, 0x36, 0x87, 0x07, 0xd8,
	0xf1, 0xfa, 0xf8, 0x20, 0x74, 0x46, 0x40, 0xda, 0x78, 0x19, 0x2a, 0x87, 0xd4, 0xe5, 0xd8, 0x76,
	0x89, 0x7f, 0x46, 0x38, 0xb6, 0x30, 0xc7, 0xe8, 0x0d, 0x58, 0xf3, 0xa8, 0xd5, 0x09, 0x6c, 0x4b,
	0x55, 0xea, 0x4a, 0x63, 0xc3, 0x58, 0xf5, 0xa8, 0xf5, 0x8d, 0x6d, 0xa1, 0x77, 0x60, 0x2b, 0x74,
	0xb8, 0x78, 0x40, 0x98, 0x87, 0x4d, 0xa2, 0x16, 0x85, 0x7b, 0xd3, 0xa3, 0xd6, 0xe3, 0xc4, 0x86,
	0xde, 0x84, 0xf5, 0x24, 0x48, 0x5d, 0x12, 0xfe, 0xb5, 0xd8, 0x8f, 0xde, 0x83, 0x6d, 0x33, 0xd9,
	0x2d, 0x0a, 0x58, 0x16, 0x01, 0x5b, 0xa9, 0x55, 0x84, 0x9d, 0xc9, 0x61, 0x7c, 0xe4, 0x11, 0x75,
	0xa5, 0xae, 0x34, 0xb6, 0x5b, 0xef, 0xeb, 0xd9, 0x8a, 0xf4, 0xa4, 0x22, 0x3d, 0xad, 0xe1, 0xeb,
	0x91, 0x47, 0x24, 0xb8, 0x70, 0x89, 0x3e, 0x80, 0x9d, 0x09, 0x9c, 0xed, 0x5a, 0xe4, 0xa9, 0xba,
	0x5a, 0x57, 0x1a, 0xcb, 0xc6, 0x64, 0x97, 0x93, 0xd0, 0x8a, 0xda, 0xb0, 0xea, 0xe0, 0x2e, 0x71,
	0x98, 0xba, 0x56, 0x5f, 0x6a, 0x94, 0x5a, 0xf7, 0xf4, 0x49, 0x8b, 0xf4, 0x29, 0x99, 0xf4, 0x53,
	0x11, 0x7b, 0xe4, 0x72, 0x7f, 0x64, 0xc4, 0x89, 0xe8, 0x1c, 0x4a, 0xd8, 0x75, 0x29, 0xc7, 0xdc,
	0xa6, 0x2e, 0x53, 0xd7, 0x05, 0x8e, 0xbe, 0x18, 0xa7, 0x3d, 0x49, 0x88, 0xc0, 0x64, 0x08, 0x74,
	0x17, 0x36, 0x6e, 0x28, 0xeb, 0x38, 0x64, 0x48, 0x1c, 0x75, 0x43, 0xc8, 0xb5, 0x7e, 0x43, 0xd9,
	0x69, 0xb8, 0x46, 0x0d, 0xd8, 0xf1, 0xc9, 0x4d, 0x40, 0x18, 0xbf, 0x08, 0xb0, 0xcb, 0x6d, 0x3e,
	0x52, 0x41, 0x94, 0x96, 0x37, 0x57, 0x3f, 0x86, 0x92, 0xc4, 0x17, 0x95, 0x61, 0xe9, 0x9a, 0x8c,
	0xe2, 0xf6, 0x86, 0x9f, 0x68, 0x17, 0x56, 0x86, 0xd8, 0x09, 0x92, 0x9e, 0x46, 0x8b, 0x47, 0xc5,
	0x8f, 0x94, 0xea, 0xa7, 0x50, 0xce, 0x53, 0x7c, 0x99, 0x7c, 0xed, 0x0e, 0xec, 0xb6, 0x2d, 0x2b,
	0xad, 0xdb, 0x20, 0xcc, 0xa3, 0x2e, 0x23, 0xda, 0x1a, 0xac, 0x1c, 0x0d, 0x3c, 0x3e, 0xd2, 0x3e,
	0x84, 0xb2, 0x41, 0x06, 0x74, 0x48, 0xce, 0xa9, 0x65, 0x44, 0xbc, 0xe7, 0x9e, 0x41, 0xed, 0x35,
	0xa8, 0x48, 0xc1, 0x31, 0xd4, 0xcf, 0x45, 0xd8, 0x3d, 0xb5, 0x19, 0x6f, 0xbb, 0xd6, 0x25, 0xe6,
	0x66, 0x3f, 0x71, 0xa0, 0x0b, 0x28, 0x85, 0x30, 0xc4, 0xe5, 0xbe, 0x4d, 0x98, 0xaa, 0x88, 0x7e,
	0xdc, 0x97, 0xfb, 0x31, 0x2b, 0x4d, 0x3f, 0xa7, 0xd6, 0x51, 0x94, 0x12, 0x75, 0x04, 0xbc, 0xd4,
	0x80, 0x3e, 0x83, 0x2d, 0xf2, 0x94, 0xfb, 0x38, 0x05, 0x2d, 0x0a, 0xd0, 0xbb, 0x99, 0x26, 0x63,
	0xc7, 0x0c, 0x1c, 0x21, 0xd8, 0x89, 0x7b, 0x45, 0x8d, 0x4d, 0x91, 0x11, 0x23, 0x54, 0x7f, 0x80,
	0x9d, 0xdc, 0x06, 0x33, 0xf4, 0x7c, 0x28, 0xeb, 0x59, 0x6a, 0xd5, 0xe6, 0xc0, 0xc7, 0x28, 0xb2,
	0xde, 0x7f, 0x2b, 0x80, 0xa6, 0x23, 0x10, 0x86, 0xca, 0xe4, 0x37, 0xc8, 0x0a, 0xf2, 0x70, 0x31,
	0xf8, 0xe4, 0xcc, 0x66, 0x44, 0x29, 0x9b, 0x39, 0x73, 0xf5, 0x09, 0xbc, 0x3e, 0x33, 0x74, 0x46,
	0x79, 0x07, 0xd9, 0xf2, 0x16, 0xaa, 0x27, 0xd5, 0xf6, 0x4c, 0x81, 0x9d, 0x9c, 0x1b, 0xbd, 0x0d,
	0x25, 0xb3, 0xe7, 0xd3, 0xc0, 0xeb, 0x78, 0x98, 0xf7, 0xe3, 0x4d, 0x20, 0x32, 0x9d, 0x63, 0xde,
	0x47, 0xa7, 0x80, 0xcc, 0x49, 0x4e, 0xc7, 0x27, 0x2c, 0x70, 0x78, 0xbc, 0xf1, 0xde, 0x9c, 0x8d,
	0x0d, 0x11, 0x64, 0x54, 0xcc, 0xbc, 0x49, 0xfb, 0x55, 0x81, 0xca, 0x54, 0x60, 0x38, 0x3b, 0x04,
	0xcb, 0x44, 0xd2, 0x7b, 0x0b, 0x71, 0xf5, 0x6f, 0x45, 0x6c, 0x3c, 0x3b, 0xa2, 0xc4, 0xf0, 0x17,
	0x95, 0xcc, 0x2f, 0xf5, 0x8b, 0xfd, 0xae, 0x80, 0x3a, 0x35, 0x58, 0x92, 0xc6, 0x7f, 0x09, 0x6b,
	0xd9, 0x76, 0x1f, 0x2c, 0x9c, 0x47, 0x49, 0xd3, 0x33, 0xbd, 0x4e, 0x10, 0xaa, 0xdf, 0xc1, 0xe6,
	0x2d, 0x9d, 0x7d, 0x90, 0xed, 0xec, 0xde, 0xc2, 0xcd, 0xe4, 0x22, 0x7e, 0x53, 0xa0, 0x7c, 0x4c,
	0x78, 0xdb, 0x1a, 0xda, 0x26, 0x49, 0xe6, 0xc0, 0x61, 0x9e, 0x7c, 0x46, 0xd8, 0x7c, 0xf8, 0x1c,
	0xd2, 0x4f, 0x6e, 0x25, 0xfd, 0x28, 0x4b, 0xfa, 0xdd, 0xff, 0xa3, 0x90, 0xcc, 0xfd, 0xa7, 0x22,
	0x54, 0x24, 0x32, 0xf1, 0xf4, 0x79, 0x3c, 0x6b, 0xfa, 0xec, 0xcf, 0x29, 0xe0, 0x55, 0x18, 0x3d,
	0x97, 0x70, 0x27, 0x9c, 0xa7, 0xa9, 0x62, 0x2c, 0x95, 0xe2, 0x13, 0x80, 0x74, 0x5c, 0x24, 0x4a,
	0xdc, 0x72, 0x34, 0xa4, 0x84, 0xd6, 0x1f, 0x45, 0xd8, 0x6e, 0x47, 0xc1, 0x5f, 0x11, 0x3f, 0x14,
	0x0c, 0x5d, 0xc0, 0xa6, 0x7c, 0xad, 0xa0, 0xc5, 0x68, 0xd5, 0xba, 0xec, 0x9e, 0x79, 0x1f, 0x15,
	0xd0, 0x17, 0xb0, 0x91, 0xde, 0x2d, 0xe8, 0x2d, 0x39, 0x21, 0x7f, 0x3f, 0x55, 0xf7, 0xe6, 0x78,
	0x53, 0xac, 0x63, 0xd8, 0x94, 0xaf, 0x16, 0x54, 0x91, 0x13, 0xc4, 0xbd, 0x97, 0xa5, 0x34, 0xeb,
	0x1e, 0xd2, 0x0a, 0xf7, 0x95, 0x90, 0x54, 0x7a, 0x4a, 0xb2, 0xa4, 0xf2, 0xa7, 0x3f, 0x4b, 0x6a,
	0xea, 0x68, 0x69, 0x85, 0xd6, 0x25, 0xc0, 0x85, 0x71, 0x96, 0x28, 0x78, 0x02, 0xdb, 0xd9, 0x6e,
	0xcd, 0x22, 0xa9, 0xe5, 0x49, 0x4e, 0x37, 0x57, 0x2b, 0x7c, 0x8e, 0x9f, 0xbf, 0xa8, 0x29, 0x7f,
	0xbd, 0xa8, 0x15, 0x9e, 0x8d, 0x6b, 0xca, 0xf3, 0x71, 0x4d, 0xf9, 0x73, 0x5c, 0x53, 0xfe, 0x19,
	0xd7, 0x94, 0x5f, 0xfe, 0xad, 0x15, 0xbe, 0x3f, 0x9c, 0xfd, 0x5e, 0xc5, 0x1c, 0x3b, 0x23, 0xc6,
	0xf7, 0x4d, 0xea, 0x93, 0xe8, 0xd5, 0xda, 0x23, 0x2e, 0x6f, 0xde, 0xf8, 0x83, 0xfd, 0xe8, 0x81,
	0xc7, 0x9a, 0x93, 0xbd, 0xbb, 0xab, 0xe2, 0xc9, 0xfa, 0xe0, 0xbf, 0x00, 0x00, 0x00, 0xff, 0xff,
	0xb8, 0xec, 0x89, 0x4c, 0x4b, 0x0b, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var (
	_ context.Context
	_ grpc.ClientConn
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// AdvisorServiceClient is the client API for AdvisorService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AdvisorServiceClient interface {
	AddContainer(ctx context.Context, in *ContainerMetadata, opts ...grpc.CallOption) (*AddContainerResponse, error)
	RemovePod(ctx context.Context, in *RemovePodRequest, opts ...grpc.CallOption) (*RemovePodResponse, error)
	ListAndWatch(ctx context.Context, in *Empty, opts ...grpc.CallOption) (AdvisorService_ListAndWatchClient, error)
	GetAdvice(ctx context.Context, in *GetAdviceRequest, opts ...grpc.CallOption) (*GetAdviceResponse, error)
}

type advisorServiceClient struct {
	cc *grpc.ClientConn
}

func NewAdvisorServiceClient(cc *grpc.ClientConn) AdvisorServiceClient {
	return &advisorServiceClient{cc}
}

func (c *advisorServiceClient) AddContainer(ctx context.Context, in *ContainerMetadata, opts ...grpc.CallOption) (*AddContainerResponse, error) {
	out := new(AddContainerResponse)
	err := c.cc.Invoke(ctx, "/advisorsvc.AdvisorService/AddContainer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *advisorServiceClient) RemovePod(ctx context.Context, in *RemovePodRequest, opts ...grpc.CallOption) (*RemovePodResponse, error) {
	out := new(RemovePodResponse)
	err := c.cc.Invoke(ctx, "/advisorsvc.AdvisorService/RemovePod", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *advisorServiceClient) ListAndWatch(ctx context.Context, in *Empty, opts ...grpc.CallOption) (AdvisorService_ListAndWatchClient, error) {
	stream, err := c.cc.NewStream(ctx, &_AdvisorService_serviceDesc.Streams[0], "/advisorsvc.AdvisorService/ListAndWatch", opts...)
	if err != nil {
		return nil, err
	}
	x := &advisorServiceListAndWatchClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AdvisorService_ListAndWatchClient interface {
	Recv() (*ListAndWatchResponse, error)
	grpc.ClientStream
}

type advisorServiceListAndWatchClient struct {
	grpc.ClientStream
}

func (x *advisorServiceListAndWatchClient) Recv() (*ListAndWatchResponse, error) {
	m := new(ListAndWatchResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *advisorServiceClient) GetAdvice(ctx context.Context, in *GetAdviceRequest, opts ...grpc.CallOption) (*GetAdviceResponse, error) {
	out := new(GetAdviceResponse)
	err := c.cc.Invoke(ctx, "/advisorsvc.AdvisorService/GetAdvice", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AdvisorServiceServer is the server API for AdvisorService service.
type AdvisorServiceServer interface {
	AddContainer(context.Context, *ContainerMetadata) (*AddContainerResponse, error)
	RemovePod(context.Context, *RemovePodRequest) (*RemovePodResponse, error)
	ListAndWatch(*Empty, AdvisorService_ListAndWatchServer) error
	GetAdvice(context.Context, *GetAdviceRequest) (*GetAdviceResponse, error)
}

// UnimplementedAdvisorServiceServer can be embedded to have forward compatible implementations.
type UnimplementedAdvisorServiceServer struct{}

func (*UnimplementedAdvisorServiceServer) AddContainer(ctx context.Context, req *ContainerMetadata) (*AddContainerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddContainer not implemented")
}

func (*UnimplementedAdvisorServiceServer) RemovePod(ctx context.Context, req *RemovePodRequest) (*RemovePodResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemovePod not implemented")
}

func (*UnimplementedAdvisorServiceServer) ListAndWatch(req *Empty, srv AdvisorService_ListAndWatchServer) error {
	return status.Errorf(codes.Unimplemented, "method ListAndWatch not implemented")
}

func (*UnimplementedAdvisorServiceServer) GetAdvice(ctx context.Context, req *GetAdviceRequest) (*GetAdviceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAdvice not implemented")
}

func RegisterAdvisorServiceServer(s *grpc.Server, srv AdvisorServiceServer) {
	s.RegisterService(&_AdvisorService_serviceDesc, srv)
}

func _AdvisorService_AddContainer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContainerMetadata)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdvisorServiceServer).AddContainer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/advisorsvc.AdvisorService/AddContainer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdvisorServiceServer).AddContainer(ctx, req.(*ContainerMetadata))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdvisorService_RemovePod_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemovePodRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdvisorServiceServer).RemovePod(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/advisorsvc.AdvisorService/RemovePod",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdvisorServiceServer).RemovePod(ctx, req.(*RemovePodRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdvisorService_ListAndWatch_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AdvisorServiceServer).ListAndWatch(m, &advisorServiceListAndWatchServer{stream})
}

type AdvisorService_ListAndWatchServer interface {
	Send(*ListAndWatchResponse) error
	grpc.ServerStream
}

type advisorServiceListAndWatchServer struct {
	grpc.ServerStream
}

func (x *advisorServiceListAndWatchServer) Send(m *ListAndWatchResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _AdvisorService_GetAdvice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAdviceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdvisorServiceServer).GetAdvice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/advisorsvc.AdvisorService/GetAdvice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdvisorServiceServer).GetAdvice(ctx, req.(*GetAdviceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _AdvisorService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "advisorsvc.AdvisorService",
	HandlerType: (*AdvisorServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddContainer",
			Handler:    _AdvisorService_AddContainer_Handler,
		},
		{
			MethodName: "RemovePod",
			Handler:    _AdvisorService_RemovePod_Handler,
		},
		{
			MethodName: "GetAdvice",
			Handler:    _AdvisorService_GetAdvice_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListAndWatch",
			Handler:       _AdvisorService_ListAndWatch_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "advisor_svc.proto",
}

// QRMServiceClient is the client API for QRMService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type QRMServiceClient interface {
	ListContainers(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListContainersResponse, error)
}

type qRMServiceClient struct {
	cc *grpc.ClientConn
}

func NewQRMServiceClient(cc *grpc.ClientConn) QRMServiceClient {
	return &qRMServiceClient{cc}
}

func (c *qRMServiceClient) ListContainers(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListContainersResponse, error) {
	out := new(ListContainersResponse)
	err := c.cc.Invoke(ctx, "/advisorsvc.QRMService/ListContainers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// QRMServiceServer is the server API for QRMService service.
type QRMServiceServer interface {
	ListContainers(context.Context, *Empty) (*ListContainersResponse, error)
}

// UnimplementedQRMServiceServer can be embedded to have forward compatible implementations.
type UnimplementedQRMServiceServer struct{}

func (*UnimplementedQRMServiceServer) ListContainers(ctx context.Context, req *Empty) (*ListContainersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListContainers not implemented")
}

func RegisterQRMServiceServer(s *grpc.Server, srv QRMServiceServer) {
	s.RegisterService(&_QRMService_serviceDesc, srv)
}

func _QRMService_ListContainers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QRMServiceServer).ListContainers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/advisorsvc.QRMService/ListContainers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QRMServiceServer).ListContainers(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _QRMService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "advisorsvc.QRMService",
	HandlerType: (*QRMServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListContainers",
			Handler:    _QRMService_ListContainers_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "advisor_svc.proto",
}

func (m *ContainerMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContainerMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RequestQuantity != 0 {
		i = encodeVarintAdvisorSvc(dAtA, i, uint64(m.RequestQuantity))
		i--
		dAtA[i] = 0x50
	}
	if len(m.QosLevel) > 0 {
		i -= len(m.QosLevel)
		copy(dAtA[i:], m.QosLevel)
		i = encodeVarintAdvisorSvc(dAtA, i, uint64(len(m.QosLevel)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Annotations) > 0 {
		for k := range m.Annotations {
			v := m.Annotations[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAdvisorSvc(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAdvisorSvc(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAdvisorSvc(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.Labels) > 0 {
		for k := range m.Labels {
			v := m.Labels[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAdvisorSvc(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAdvisorSvc(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAdvisorSvc(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.ContainerIndex != 0 {
		i = encodeVarintAdvisorSvc(dAtA, i, uint64(m.ContainerIndex))
		i--
		dAtA[i] = 0x30
	}
	if m.ContainerType != 0 {
		i = encodeVarintAdvisorSvc(dAtA, i, uint64(m.ContainerType))
		i--
		dAtA[i] = 0x28
	}
	if len(m.ContainerName) > 0 {
		i -= len(m.ContainerName)
		copy(dAtA[i:], m.ContainerName)
		i = encodeVarintAdvisorSvc(dAtA, i, uint64(len(m.ContainerName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.PodName) > 0 {
		i -= len(m.PodName)
		copy(dAtA[i:], m.PodName)
		i = encodeVarintAdvisorSvc(dAtA, i, uint64(len(m.PodName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.PodNamespace) > 0 {
		i -= len(m.PodNamespace)
		copy(dAtA[i:], m.PodNamespace)
		i = encodeVarintAdvisorSvc(dAtA, i, uint64(len(m.PodNamespace)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PodUid) > 0 {
		i -= len(m.PodUid)
		copy(dAtA[i:], m.PodUid)
		i = encodeVarintAdvisorSvc(dAtA, i, uint64(len(m.PodUid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AddContainerResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddContainerResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddContainerResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *Empty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Empty) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Empty) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *RemovePodRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemovePodRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemovePodRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PodUid) > 0 {
		i -= len(m.PodUid)
		copy(dAtA[i:], m.PodUid)
		i = encodeVarintAdvisorSvc(dAtA, i, uint64(len(m.PodUid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RemovePodResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemovePodResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemovePodResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ListAndWatchResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListAndWatchResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListAndWatchResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ExtraEntries) > 0 {
		for iNdEx := len(m.ExtraEntries) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ExtraEntries[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdvisorSvc(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.PodEntries) > 0 {
		for k := range m.PodEntries {
			v := m.PodEntries[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintAdvisorSvc(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAdvisorSvc(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAdvisorSvc(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CalculationEntries) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CalculationEntries) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CalculationEntries) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ContainerEntries) > 0 {
		for k := range m.ContainerEntries {
			v := m.ContainerEntries[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintAdvisorSvc(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAdvisorSvc(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAdvisorSvc(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CalculationInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CalculationInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CalculationInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CalculationResult != nil {
		{
			size, err := m.CalculationResult.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAdvisorSvc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.CgroupPath) > 0 {
		i -= len(m.CgroupPath)
		copy(dAtA[i:], m.CgroupPath)
		i = encodeVarintAdvisorSvc(dAtA, i, uint64(len(m.CgroupPath)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CalculationResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CalculationResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CalculationResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Values) > 0 {
		for k := range m.Values {
			v := m.Values[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAdvisorSvc(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAdvisorSvc(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAdvisorSvc(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ContainerMetadataEntries) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerMetadataEntries) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContainerMetadataEntries) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for k := range m.Entries {
			v := m.Entries[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintAdvisorSvc(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAdvisorSvc(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAdvisorSvc(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetAdviceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAdviceRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetAdviceRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for k := range m.Entries {
			v := m.Entries[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintAdvisorSvc(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAdvisorSvc(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAdvisorSvc(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetAdviceResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAdviceResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetAdviceResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ExtraEntries) > 0 {
		for iNdEx := len(m.ExtraEntries) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ExtraEntries[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdvisorSvc(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.PodEntries) > 0 {
		for k := range m.PodEntries {
			v := m.PodEntries[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintAdvisorSvc(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAdvisorSvc(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAdvisorSvc(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ListContainersResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListContainersResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListContainersResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Containers) > 0 {
		for iNdEx := len(m.Containers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Containers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdvisorSvc(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintAdvisorSvc(dAtA []byte, offset int, v uint64) int {
	offset -= sovAdvisorSvc(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}

func (m *ContainerMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PodUid)
	if l > 0 {
		n += 1 + l + sovAdvisorSvc(uint64(l))
	}
	l = len(m.PodNamespace)
	if l > 0 {
		n += 1 + l + sovAdvisorSvc(uint64(l))
	}
	l = len(m.PodName)
	if l > 0 {
		n += 1 + l + sovAdvisorSvc(uint64(l))
	}
	l = len(m.ContainerName)
	if l > 0 {
		n += 1 + l + sovAdvisorSvc(uint64(l))
	}
	if m.ContainerType != 0 {
		n += 1 + sovAdvisorSvc(uint64(m.ContainerType))
	}
	if m.ContainerIndex != 0 {
		n += 1 + sovAdvisorSvc(uint64(m.ContainerIndex))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAdvisorSvc(uint64(len(k))) + 1 + len(v) + sovAdvisorSvc(uint64(len(v)))
			n += mapEntrySize + 1 + sovAdvisorSvc(uint64(mapEntrySize))
		}
	}
	if len(m.Annotations) > 0 {
		for k, v := range m.Annotations {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAdvisorSvc(uint64(len(k))) + 1 + len(v) + sovAdvisorSvc(uint64(len(v)))
			n += mapEntrySize + 1 + sovAdvisorSvc(uint64(mapEntrySize))
		}
	}
	l = len(m.QosLevel)
	if l > 0 {
		n += 1 + l + sovAdvisorSvc(uint64(l))
	}
	if m.RequestQuantity != 0 {
		n += 1 + sovAdvisorSvc(uint64(m.RequestQuantity))
	}
	return n
}

func (m *AddContainerResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *Empty) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *RemovePodRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PodUid)
	if l > 0 {
		n += 1 + l + sovAdvisorSvc(uint64(l))
	}
	return n
}

func (m *RemovePodResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ListAndWatchResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PodEntries) > 0 {
		for k, v := range m.PodEntries {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovAdvisorSvc(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovAdvisorSvc(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovAdvisorSvc(uint64(mapEntrySize))
		}
	}
	if len(m.ExtraEntries) > 0 {
		for _, e := range m.ExtraEntries {
			l = e.Size()
			n += 1 + l + sovAdvisorSvc(uint64(l))
		}
	}
	return n
}

func (m *CalculationEntries) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ContainerEntries) > 0 {
		for k, v := range m.ContainerEntries {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovAdvisorSvc(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovAdvisorSvc(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovAdvisorSvc(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *CalculationInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CgroupPath)
	if l > 0 {
		n += 1 + l + sovAdvisorSvc(uint64(l))
	}
	if m.CalculationResult != nil {
		l = m.CalculationResult.Size()
		n += 1 + l + sovAdvisorSvc(uint64(l))
	}
	return n
}

func (m *CalculationResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Values) > 0 {
		for k, v := range m.Values {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAdvisorSvc(uint64(len(k))) + 1 + len(v) + sovAdvisorSvc(uint64(len(v)))
			n += mapEntrySize + 1 + sovAdvisorSvc(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ContainerMetadataEntries) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for k, v := range m.Entries {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovAdvisorSvc(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovAdvisorSvc(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovAdvisorSvc(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *GetAdviceRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for k, v := range m.Entries {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovAdvisorSvc(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovAdvisorSvc(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovAdvisorSvc(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *GetAdviceResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PodEntries) > 0 {
		for k, v := range m.PodEntries {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovAdvisorSvc(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovAdvisorSvc(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovAdvisorSvc(uint64(mapEntrySize))
		}
	}
	if len(m.ExtraEntries) > 0 {
		for _, e := range m.ExtraEntries {
			l = e.Size()
			n += 1 + l + sovAdvisorSvc(uint64(l))
		}
	}
	return n
}

func (m *ListContainersResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Containers) > 0 {
		for _, e := range m.Containers {
			l = e.Size()
			n += 1 + l + sovAdvisorSvc(uint64(l))
		}
	}
	return n
}

func sovAdvisorSvc(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}

func sozAdvisorSvc(x uint64) (n int) {
	return sovAdvisorSvc(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}

func (this *ContainerMetadata) String() string {
	if this == nil {
		return "nil"
	}
	keysForLabels := make([]string, 0, len(this.Labels))
	for k := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%v: %v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	keysForAnnotations := make([]string, 0, len(this.Annotations))
	for k := range this.Annotations {
		keysForAnnotations = append(keysForAnnotations, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAnnotations)
	mapStringForAnnotations := "map[string]string{"
	for _, k := range keysForAnnotations {
		mapStringForAnnotations += fmt.Sprintf("%v: %v,", k, this.Annotations[k])
	}
	mapStringForAnnotations += "}"
	s := strings.Join([]string{
		`&ContainerMetadata{`,
		`PodUid:` + fmt.Sprintf("%v", this.PodUid) + `,`,
		`PodNamespace:` + fmt.Sprintf("%v", this.PodNamespace) + `,`,
		`PodName:` + fmt.Sprintf("%v", this.PodName) + `,`,
		`ContainerName:` + fmt.Sprintf("%v", this.ContainerName) + `,`,
		`ContainerType:` + fmt.Sprintf("%v", this.ContainerType) + `,`,
		`ContainerIndex:` + fmt.Sprintf("%v", this.ContainerIndex) + `,`,
		`Labels:` + mapStringForLabels + `,`,
		`Annotations:` + mapStringForAnnotations + `,`,
		`QosLevel:` + fmt.Sprintf("%v", this.QosLevel) + `,`,
		`RequestQuantity:` + fmt.Sprintf("%v", this.RequestQuantity) + `,`,
		`}`,
	}, "")
	return s
}

func (this *AddContainerResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{
		`&AddContainerResponse{`,
		`}`,
	}, "")
	return s
}

func (this *Empty) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{
		`&Empty{`,
		`}`,
	}, "")
	return s
}

func (this *RemovePodRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{
		`&RemovePodRequest{`,
		`PodUid:` + fmt.Sprintf("%v", this.PodUid) + `,`,
		`}`,
	}, "")
	return s
}

func (this *RemovePodResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{
		`&RemovePodResponse{`,
		`}`,
	}, "")
	return s
}

func (this *ListAndWatchResponse) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForExtraEntries := "[]*CalculationInfo{"
	for _, f := range this.ExtraEntries {
		repeatedStringForExtraEntries += strings.Replace(f.String(), "CalculationInfo", "CalculationInfo", 1) + ","
	}
	repeatedStringForExtraEntries += "}"
	keysForPodEntries := make([]string, 0, len(this.PodEntries))
	for k := range this.PodEntries {
		keysForPodEntries = append(keysForPodEntries, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForPodEntries)
	mapStringForPodEntries := "map[string]*CalculationEntries{"
	for _, k := range keysForPodEntries {
		mapStringForPodEntries += fmt.Sprintf("%v: %v,", k, this.PodEntries[k])
	}
	mapStringForPodEntries += "}"
	s := strings.Join([]string{
		`&ListAndWatchResponse{`,
		`PodEntries:` + mapStringForPodEntries + `,`,
		`ExtraEntries:` + repeatedStringForExtraEntries + `,`,
		`}`,
	}, "")
	return s
}

func (this *CalculationEntries) String() string {
	if this == nil {
		return "nil"
	}
	keysForContainerEntries := make([]string, 0, len(this.ContainerEntries))
	for k := range this.ContainerEntries {
		keysForContainerEntries = append(keysForContainerEntries, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForContainerEntries)
	mapStringForContainerEntries := "map[string]*CalculationInfo{"
	for _, k := range keysForContainerEntries {
		mapStringForContainerEntries += fmt.Sprintf("%v: %v,", k, this.ContainerEntries[k])
	}
	mapStringForContainerEntries += "}"
	s := strings.Join([]string{
		`&CalculationEntries{`,
		`ContainerEntries:` + mapStringForContainerEntries + `,`,
		`}`,
	}, "")
	return s
}

func (this *CalculationInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{
		`&CalculationInfo{`,
		`CgroupPath:` + fmt.Sprintf("%v", this.CgroupPath) + `,`,
		`CalculationResult:` + strings.Replace(this.CalculationResult.String(), "CalculationResult", "CalculationResult", 1) + `,`,
		`}`,
	}, "")
	return s
}

func (this *CalculationResult) String() string {
	if this == nil {
		return "nil"
	}
	keysForValues := make([]string, 0, len(this.Values))
	for k := range this.Values {
		keysForValues = append(keysForValues, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForValues)
	mapStringForValues := "map[string]string{"
	for _, k := range keysForValues {
		mapStringForValues += fmt.Sprintf("%v: %v,", k, this.Values[k])
	}
	mapStringForValues += "}"
	s := strings.Join([]string{
		`&CalculationResult{`,
		`Values:` + mapStringForValues + `,`,
		`}`,
	}, "")
	return s
}

func (this *ContainerMetadataEntries) String() string {
	if this == nil {
		return "nil"
	}
	keysForEntries := make([]string, 0, len(this.Entries))
	for k := range this.Entries {
		keysForEntries = append(keysForEntries, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForEntries)
	mapStringForEntries := "map[string]*ContainerMetadata{"
	for _, k := range keysForEntries {
		mapStringForEntries += fmt.Sprintf("%v: %v,", k, this.Entries[k])
	}
	mapStringForEntries += "}"
	s := strings.Join([]string{
		`&ContainerMetadataEntries{`,
		`Entries:` + mapStringForEntries + `,`,
		`}`,
	}, "")
	return s
}

func (this *GetAdviceRequest) String() string {
	if this == nil {
		return "nil"
	}
	keysForEntries := make([]string, 0, len(this.Entries))
	for k := range this.Entries {
		keysForEntries = append(keysForEntries, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForEntries)
	mapStringForEntries := "map[string]*ContainerMetadataEntries{"
	for _, k := range keysForEntries {
		mapStringForEntries += fmt.Sprintf("%v: %v,", k, this.Entries[k])
	}
	mapStringForEntries += "}"
	s := strings.Join([]string{
		`&GetAdviceRequest{`,
		`Entries:` + mapStringForEntries + `,`,
		`}`,
	}, "")
	return s
}

func (this *GetAdviceResponse) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForExtraEntries := "[]*CalculationInfo{"
	for _, f := range this.ExtraEntries {
		repeatedStringForExtraEntries += strings.Replace(f.String(), "CalculationInfo", "CalculationInfo", 1) + ","
	}
	repeatedStringForExtraEntries += "}"
	keysForPodEntries := make([]string, 0, len(this.PodEntries))
	for k := range this.PodEntries {
		keysForPodEntries = append(keysForPodEntries, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForPodEntries)
	mapStringForPodEntries := "map[string]*CalculationEntries{"
	for _, k := range keysForPodEntries {
		mapStringForPodEntries += fmt.Sprintf("%v: %v,", k, this.PodEntries[k])
	}
	mapStringForPodEntries += "}"
	s := strings.Join([]string{
		`&GetAdviceResponse{`,
		`PodEntries:` + mapStringForPodEntries + `,`,
		`ExtraEntries:` + repeatedStringForExtraEntries + `,`,
		`}`,
	}, "")
	return s
}

func (this *ListContainersResponse) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForContainers := "[]*ContainerMetadata{"
	for _, f := range this.Containers {
		repeatedStringForContainers += strings.Replace(f.String(), "ContainerMetadata", "ContainerMetadata", 1) + ","
	}
	repeatedStringForContainers += "}"
	s := strings.Join([]string{
		`&ListContainersResponse{`,
		`Containers:` + repeatedStringForContainers + `,`,
		`}`,
	}, "")
	return s
}

func valueToStringAdvisorSvc(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}

func (m *ContainerMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdvisorSvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodUid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisorSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisorSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdvisorSvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PodUid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodNamespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisorSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisorSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdvisorSvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PodNamespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisorSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisorSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdvisorSvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PodName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisorSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisorSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdvisorSvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerType", wireType)
			}
			m.ContainerType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisorSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContainerType |= v1alpha1.ContainerType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerIndex", wireType)
			}
			m.ContainerIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisorSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContainerIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisorSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdvisorSvc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdvisorSvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdvisorSvc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdvisorSvc
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAdvisorSvc
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAdvisorSvc
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdvisorSvc
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAdvisorSvc
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAdvisorSvc
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAdvisorSvc(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthAdvisorSvc
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisorSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdvisorSvc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdvisorSvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdvisorSvc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdvisorSvc
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAdvisorSvc
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAdvisorSvc
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdvisorSvc
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAdvisorSvc
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAdvisorSvc
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAdvisorSvc(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthAdvisorSvc
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Annotations[mapkey] = mapvalue
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QosLevel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisorSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisorSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdvisorSvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QosLevel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestQuantity", wireType)
			}
			m.RequestQuantity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisorSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestQuantity |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAdvisorSvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdvisorSvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}

func (m *AddContainerResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdvisorSvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddContainerResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddContainerResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAdvisorSvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdvisorSvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}

func (m *Empty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdvisorSvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Empty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Empty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAdvisorSvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdvisorSvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}

func (m *RemovePodRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdvisorSvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemovePodRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemovePodRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodUid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisorSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisorSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdvisorSvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PodUid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdvisorSvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdvisorSvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}

func (m *RemovePodResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdvisorSvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemovePodResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemovePodResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAdvisorSvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdvisorSvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}

func (m *ListAndWatchResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdvisorSvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListAndWatchResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListAndWatchResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodEntries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisorSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdvisorSvc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdvisorSvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PodEntries == nil {
				m.PodEntries = make(map[string]*CalculationEntries)
			}
			var mapkey string
			var mapvalue *CalculationEntries
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdvisorSvc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdvisorSvc
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAdvisorSvc
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAdvisorSvc
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdvisorSvc
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthAdvisorSvc
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthAdvisorSvc
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &CalculationEntries{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAdvisorSvc(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthAdvisorSvc
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.PodEntries[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraEntries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisorSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdvisorSvc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdvisorSvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtraEntries = append(m.ExtraEntries, &CalculationInfo{})
			if err := m.ExtraEntries[len(m.ExtraEntries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdvisorSvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdvisorSvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}

func (m *CalculationEntries) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdvisorSvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CalculationEntries: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CalculationEntries: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerEntries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisorSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdvisorSvc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdvisorSvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ContainerEntries == nil {
				m.ContainerEntries = make(map[string]*CalculationInfo)
			}
			var mapkey string
			var mapvalue *CalculationInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdvisorSvc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdvisorSvc
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAdvisorSvc
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAdvisorSvc
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdvisorSvc
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthAdvisorSvc
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthAdvisorSvc
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &CalculationInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAdvisorSvc(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthAdvisorSvc
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ContainerEntries[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdvisorSvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdvisorSvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}

func (m *CalculationInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdvisorSvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CalculationInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CalculationInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CgroupPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisorSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisorSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdvisorSvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CgroupPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CalculationResult", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisorSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdvisorSvc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdvisorSvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CalculationResult == nil {
				m.CalculationResult = &CalculationResult{}
			}
			if err := m.CalculationResult.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdvisorSvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdvisorSvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}

func (m *CalculationResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdvisorSvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CalculationResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CalculationResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisorSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdvisorSvc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdvisorSvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Values == nil {
				m.Values = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdvisorSvc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdvisorSvc
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAdvisorSvc
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAdvisorSvc
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdvisorSvc
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAdvisorSvc
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAdvisorSvc
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAdvisorSvc(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthAdvisorSvc
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Values[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdvisorSvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdvisorSvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}

func (m *ContainerMetadataEntries) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdvisorSvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerMetadataEntries: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerMetadataEntries: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisorSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdvisorSvc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdvisorSvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Entries == nil {
				m.Entries = make(map[string]*ContainerMetadata)
			}
			var mapkey string
			var mapvalue *ContainerMetadata
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdvisorSvc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdvisorSvc
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAdvisorSvc
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAdvisorSvc
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdvisorSvc
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthAdvisorSvc
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthAdvisorSvc
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ContainerMetadata{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAdvisorSvc(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthAdvisorSvc
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Entries[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdvisorSvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdvisorSvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}

func (m *GetAdviceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdvisorSvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAdviceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAdviceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisorSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdvisorSvc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdvisorSvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Entries == nil {
				m.Entries = make(map[string]*ContainerMetadataEntries)
			}
			var mapkey string
			var mapvalue *ContainerMetadataEntries
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdvisorSvc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdvisorSvc
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAdvisorSvc
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAdvisorSvc
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdvisorSvc
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthAdvisorSvc
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthAdvisorSvc
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ContainerMetadataEntries{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAdvisorSvc(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthAdvisorSvc
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Entries[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdvisorSvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdvisorSvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}

func (m *GetAdviceResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdvisorSvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAdviceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAdviceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodEntries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisorSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdvisorSvc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdvisorSvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PodEntries == nil {
				m.PodEntries = make(map[string]*CalculationEntries)
			}
			var mapkey string
			var mapvalue *CalculationEntries
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdvisorSvc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdvisorSvc
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAdvisorSvc
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAdvisorSvc
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdvisorSvc
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthAdvisorSvc
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthAdvisorSvc
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &CalculationEntries{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAdvisorSvc(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthAdvisorSvc
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.PodEntries[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraEntries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisorSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdvisorSvc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdvisorSvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtraEntries = append(m.ExtraEntries, &CalculationInfo{})
			if err := m.ExtraEntries[len(m.ExtraEntries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdvisorSvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdvisorSvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}

func (m *ListContainersResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdvisorSvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListContainersResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListContainersResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Containers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisorSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdvisorSvc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdvisorSvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Containers = append(m.Containers, &ContainerMetadata{})
			if err := m.Containers[len(m.Containers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdvisorSvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdvisorSvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}

func skipAdvisorSvc(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAdvisorSvc
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAdvisorSvc
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAdvisorSvc
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAdvisorSvc
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupAdvisorSvc
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthAdvisorSvc
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthAdvisorSvc        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAdvisorSvc          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupAdvisorSvc = fmt.Errorf("proto: unexpected end of group")
)
